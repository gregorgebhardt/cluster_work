import os
import re
from collections import namedtuple
from typing import Iterator, Tuple

import gin
from gin import config_parser
import pandas as pd
from cluster_work._results import RepetitionResults

from ._parameter_iterator import ParameterList, ParameterGrid
from ._tools import shorten_param
from ._logging import cw_logger


@gin.configurable('cluster_work')
class ExperimentOptions:
    def __init__(self, name=gin.REQUIRED, iterations=gin.REQUIRED, repetitions=gin.REQUIRED,
                 path=gin.REQUIRED, log_path=None):
        self._name = name
        self._iterations = iterations
        self._repetitions = repetitions
        self._path = path
        # is only set if provided explicitly, otherwise generated by property
        self._log_path = log_path

    @property
    def name(self):
        return self._name

    @property
    def iterations(self):
        return self._iterations

    @property
    def repetitions(self):
        return self._repetitions

    @property
    def path(self):
        return self._path

    @property
    def log_path(self):
        if self._log_path:
            return self._log_path
        else:
            return os.path.join(self.path, 'log')


class Experiment(ExperimentOptions):
    Progress = namedtuple('Progress', ['name', 'num_repetitions', 'num_iterations', 'exp_progress', 'rep_progress',
                                       'finished_repetitions', 'finished_iterations'])

    def __init__(self, *args, **kwargs):
        super(Experiment, self).__init__(*args, **kwargs)
        self._gin_file = os.path.join(self.path, 'experiment.gin')

    # TODO add context

    def experiment_progress(self) -> 'Experiment.Progress':
        rep_progress = [self.repetition_progress(rep) for rep in range(self.repetitions)]
        rep_progress_f, rep_progress_i = map(list, zip(*rep_progress))
        exp_progress_f = sum(rep_progress_f) / self.repetitions
        exp_progress_i = sum(map(lambda i: i == self.iterations, rep_progress_i))

        return Experiment.Progress(name=self.name, num_iterations=self.iterations,
                                   num_repetitions=self.repetitions, exp_progress=exp_progress_f,
                                   rep_progress=rep_progress_f, finished_repetitions=exp_progress_i,
                                   finished_iterations=rep_progress_i)

    def repetition_progress(self, rep) -> (float, int):
        repetition_results = RepetitionResults(repetition=rep, iterations=self.iterations, path=self.path)

        if repetition_results.empty:
            return .0, 0
        completed_iterations = len(repetition_results)
        return float(completed_iterations) / self.iterations, completed_iterations

    def print_progress(self, full_progress=False):
        """ shows the progress of all experiments defined in the config_file.
        """
        exp_progress = self.experiment_progress()

        # progress bar
        num_indicators = 25
        num_marked_indicators = round(num_indicators * exp_progress.exp_progress)
        bar = "["
        bar += "." * max(num_marked_indicators - 2, 0) + '‍🌪 ' * (num_marked_indicators > 0)
        bar += " " * (num_indicators - num_marked_indicators - (num_marked_indicators == 1))
        bar += "]"

        finished_reps = '{}/{}'.format(exp_progress.finished_repetitions, exp_progress.num_repetitions)
        print('{:5.1f}% {} {}   {}'.format(exp_progress.exp_progress * 100, bar, finished_reps,
                                           exp_progress.name))

        if full_progress:
            for i, (p, f_i) in enumerate(zip(exp_progress.rep_progress, exp_progress.finished_iterations)):
                num_indicators = 25
                num_marked_indicators = round(num_indicators * p)
                bar = "["
                bar += "." * max(num_marked_indicators - 2, 0) + '💃🏽' * (num_marked_indicators > 0)
                bar += " " * (num_indicators - num_marked_indicators)
                bar += "]"
                print('    • {:2d}: {:5.1f}% {} {:3}/{}'.format(i + 1, p * 100, bar, f_i,
                                                                exp_progress.num_iterations))
            print()


class _Experiment(Experiment):
    def __init__(self, _parent: ExperimentOptions, _params: dict, *args, **kwargs):
        super(_Experiment, self).__init__(*args, **kwargs)
        self._parent = _parent
        self._params = _params

        self.old_files_exist = False
        self.old_files_identical = False

    def write_gin_file(self):
        gin_string = gin.operative_config_str()
        with open(self._gin_file, 'w') as gin_file:
            gin_file.write(gin_string)

    def create_experiment_directories(self, delete_old_files=False):
        """ creates a subdirectory for the experiment, and deletes existing
            files, if the delete flag is true. Stores the experiment.gin file in the experiment folder.
        """
        # create experiment path and subdir
        os.makedirs(self.path, exist_ok=True)

        # delete old histories if --del flag is active
        if delete_old_files:
            os.system('rm -rf {}/*'.format(self.path))

        # create a directory for the log path
        os.makedirs(self.log_path, exist_ok=True)

    def check_old_files(self):
        # idea: only checks if old_values are identical to new_values, does not check if there are new values that
        #  are not in old values...

        # check if experiment.gin file exists
        if not os.path.exists(self._gin_file):
            return
        self.old_files_exist = True

        # parse experiment.gin file and check against configured values
        self.old_files_identical = True
        with open(self._gin_file) as f:
            parser = config_parser.ConfigParser(f, gin.config.ParserDelegate)
            for statement in parser:
                if isinstance(statement, config_parser.BindingStatement):
                    scope, selector, arg_name, value, location = statement
                    if not arg_name:
                        macro_name = '{}/{}'.format(scope, selector) if scope else selector
                        try:
                            # check new_value in config
                            new_value = gin.query_parameter((macro_name, 'gin.macro', 'value'))
                        except ValueError:
                            self.old_files_identical = False
                            break
                    else:
                        try:
                            # check new_value in config
                            new_value = gin.query_parameter((scope, selector, arg_name))
                        except ValueError:
                            self.old_files_identical = False
                            break
                    # compare new_value to value in old gin_file
                    if new_value != value:
                        self.old_files_identical = False
                        break
                elif isinstance(statement, config_parser.ImportStatement):
                    cw_logger.warning('Did not expect ImportStatement in stored experiment.gin!')
                    self.old_files_identical = False
                    break
                elif isinstance(statement, config_parser.IncludeStatement):
                    cw_logger.warning('Did not expect IncludeStatement in stored experiment.gin!')
                    self.old_files_identical = False
                    break
                else:
                    cw_logger.warning('Unrecognized statement type {}.'.format(statement))
                    self.old_files_identical = False
                    break


class ExperimentCollection(ExperimentOptions):
    def __init__(self, gin_file, *args, **kwargs):
        super(ExperimentCollection, self).__init__(*args, **kwargs)
        self._gin_file = gin_file
        gin.parse_config_file(self._gin_file)

        self._grid = ParameterGrid()
        self._list = ParameterList()

    def expand(self, delete_old_files=False) -> Iterator[_Experiment]:
        for g_params in self._grid:
            for l_params in self._list:
                # merge the parameter dicts from list and grid
                params = {**g_params, **l_params}
                # adapt name and path
                adapted_name = '_'.join("{}:{}".format(shorten_param(k), v) for k, v in zip(params.keys(),
                                                                                            params.values()))
                adapted_name = re.sub(r"[' ]", '', adapted_name)
                adapted_name = re.sub(r'["]', '', adapted_name)
                adapted_name = re.sub(r"[(\[]", '_', adapted_name)
                adapted_name = re.sub(r"[)\]]", '', adapted_name)
                adapted_name = re.sub(r"[,]", '_', adapted_name)

                adapted_path = os.path.join(self.path, self.name, adapted_name)
                if adapted_name:
                    adapted_name = self.name + '__' + adapted_name
                else:
                    adapted_name = self.name
                if self._log_path:
                    adapted_log_path = os.path.join(self._log_path, adapted_name)
                else:
                    adapted_log_path = None

                gin.clear_config(clear_constants=True)
                gin.parse_config_file(self._gin_file)

                gin.bind_parameter('cluster_work.name', adapted_name)
                gin.bind_parameter('cluster_work.path', adapted_path)
                gin.bind_parameter('cluster_work.log_path', adapted_log_path)

                for k, v in params.items():
                    gin.bind_parameter(k, v)

                gin.finalize()

                exp = _Experiment(_parent=self, _params=params)
                exp.create_experiment_directories(delete_old_files=delete_old_files)
                exp.check_old_files()

                yield exp
